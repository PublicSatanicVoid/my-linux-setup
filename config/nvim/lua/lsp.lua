local neovim_venv = os.getenv("NEOVIM_VENV") or os.getenv("HOME") .. "/venvs/neovim_venv"

-- Keybinds for lsp diagnostics
local opts = { noremap=true, silent=true }
vim.keymap.set("n", "<leader>e", vim.diagnostic.open_float, opts)
vim.keymap.set("n", "[d", vim.diagnostic.goto_prev, opts)
vim.keymap.set("n", "]d", vim.diagnostic.goto_next, opts)
vim.keymap.set("n", "<leader>q", vim.diagnostic.setloclist, opts)

-- LSP-specific behavior per buffer
local on_attach = function(client, bufnr)
    -- Enable completion triggered by <c-x><c-o>
    vim.bo[bufnr].omnifunc = "v:lua.vim.lsp.omnifunc"

    -- Mappings.
    -- See `:help vim.lsp.*` for documentation on any of the below functions
    local bufopts = { noremap=true, silent=true, buffer=bufnr }
    --vim.keymap.set("n", "gD", vim.lsp.buf.declaration, bufopts)
    vim.keymap.set("n", "gd", vim.lsp.buf.definition, bufopts)
    vim.keymap.set("n", "gr", vim.lsp.buf.references, bufopts)
    vim.keymap.set("n", "K", vim.lsp.buf.hover, bufopts)
    --vim.keymap.set("n", "gi", vim.lsp.buf.implementation, bufopts)
    vim.keymap.set("n", "<C-k>", vim.lsp.buf.signature_help, bufopts)
    vim.keymap.set("n", "<leader>rn", vim.lsp.buf.rename, bufopts)
    vim.keymap.set("n", "<leader>ca", vim.lsp.buf.code_action, bufopts)
    vim.keymap.set(
        "n",
        "<leader>f",
        function() vim.lsp.buf.format { async = true } end,
        bufopts
    )
end

-- Linter: Show floating window with linter error on current line
vim.api.nvim_create_autocmd({"CursorHold"}, {
    callback = function()
        local opts = {
            focusable = false,
            close_events = {"BufLeave", "CursorMoved", "InsertEnter", "FocusLost"},
            border = "rounded",
            source = "always",
            prefix = " ",
            scope = "cursor"
        }
        vim.diagnostic.open_float(nil, opts)
    end
})

-- Show the floating window faster when trigger condition is met
vim.o.updatetime = 500

-- Linter: Configure display of linting messages in-line
vim.diagnostic.config({
    virtual_text = true,
    signs = true,
    underline = true,
    update_in_insert = false,
    severity_sort = true,
    float = { border = "rounded" }
})


-- Secondary language server for Python, only used here for code formatting
vim.lsp.config['ruff'] = {
    filetypes = { 'python' },
    on_attach = on_attach,
    cmd = { neovim_venv .. "/bin/ruff", "server" },
    init_options = {
        settings = {
            args = {"--isolated"},
            organizeImports = false,
            lint = {
                enable = false
            }
        }
    }
}

-- C/C++ language server
vim.lsp.config['clangd'] = {
    filetypes = { 'c', 'c++' },
    on_attach = on_attach,
    cmd = {
        "clangd",
        "--background-index",
        "--completion-style=detailed",

        -- "--suggest-missing-includes",
        -- "--clang-tidy",
        "--fallback-style=WebKit"
    },
    capabilities = {
        textDocument = {
            formatting = {
                formatProvider = "clang-format"
            }
        }
    }
}

-- Rust language server
vim.lsp.config['rust_analyzer'] = {
    filetypes = { 'rust' },
    on_attach = on_attach
}


vim.lsp.enable({'ruff', 'clangd', 'rust_analyzer'})



-- Allow site- or company-specific config outside public setup repo
local site_config_dir = os.getenv("HOME") .. "/etc/site"
local function get_site_config(file, default)
    local search_path = site_config_dir .. "/" .. file
    local have_config, config = pcall(dofile, search_path)
    if have_config then
        return config
    else
        return default
    end
end

-- Complicated setup for basedpyright Python LSP server
-- The key thing we're trying to do here is automatically add import paths based on
-- shebang lines, falling back to the default interpreter, and ensure duplicate servers
-- are not started up. This is important to properly support editing of both single-file
-- scripts and modules in large project repos.
-- Below this line is mostly generated by Google Gemini


local extra_py_paths = get_site_config("nvim-python-extrapaths.lua", {})
local excluded_py_paths = get_site_config("nvim-python-excludepaths.lua", {})
local default_py_exe = get_site_config("nvim-python-default-exe.lua", nil)
if not default_py_exe then
    default_py_exe = vim.fn.exepath("python3")
end

local default_pyright_lsp_settings = {
    python = {
        pythonPath = default_py_exe
    },
    basedpyright = {
        analysis = {
            autoSearchPaths = true,
            diagnosticMode = "openFilesOnly",
            useLibraryCodeForTypes = true,
            typeCheckingMode = "off",  -- too much noise for now, should reevaluate
            extraPaths = extra_py_paths,
            exclude = excluded_py_paths
        }
    }
}


-- Helper to find a parent directory containing an item matching the provided pattern
-- (From nvim-lspconfig)
local function root_pattern(...)
    local patterns = vim.tbl_flatten({ ... })

    ---@param fname string
    return function(fname)
        local path = vim.fs.normalize(fname)
        if not path then return nil end
        path = vim.fs.dirname(path)
        if not path then return nil end

        local stop = vim.fs.dirname(vim.env.HOME)
        while path and path ~= stop and path ~= '/' do
            for _, pattern in ipairs(patterns) do
                local mark = path .. '/' .. pattern
                if vim.fn.filereadable(mark) == 1 or vim.fn.isdirectory(mark) == 1 then
                    return vim.fs.normalize(path)
                end
            end
            path = vim.fs.dirname(path)
        end
        return nil
    end
end

-- Helper to find the .git root
local find_git_root = root_pattern('.git')

-- Helper to find an environment root by looking for bin/python3
local find_env_root = root_pattern('bin/python3')

-- Helper to parse the shebang line and return a canonical path
local function get_interpreter_from_shebang(bufnr)
    bufnr = bufnr or 0
    local lines = vim.api.nvim_buf_get_lines(bufnr, 0, 1, false)
    if not lines or #lines == 0 then return nil end
    local line = lines[1]
    if not line:match("^#!") then return nil end

    local path
    local env_cmd = line:match("^#!%s*/usr/bin/env%s+([^%s]+)")

    if env_cmd then
        path = vim.fn.exepath(env_cmd)
    else
        local direct_path = line:match("^#!%s*([%/][^%s]+)")
        if direct_path then
            path = vim.fn.resolve(direct_path)
        end
    end

    if path and path ~= "" and vim.fn.executable(path) == 1 then
        return path -- Already canonical
    end
    return nil
end

-- Helper to find an active client by its *resolved* pythonPath
local function find_client_by_interpreter(resolved_path)
    if not resolved_path or resolved_path == "" then return nil end

    local clients = vim.lsp.get_clients()
    for _, client in ipairs(clients) do
        if client.config and client.config.settings and client.config.settings.python then
            local client_path = client.config.settings.python.pythonPath
            if client_path and vim.fn.resolve(client_path) == resolved_path then
                return client
            end
        end
    end
    return nil
end


-- basedpyright custom startup logic

local python_lsp_group = vim.api.nvim_create_augroup('MyPythonLspStart', { clear = true })

vim.api.nvim_create_autocmd('FileType', {
    pattern = 'python',
    group = python_lsp_group,
    desc = "Start basedpyright with dynamic interpreter logic",
    callback = function(args)
        local bufnr = args.buf
        local bufname = vim.api.nvim_buf_get_name(bufnr)

        -- Determine logic, root, and interpreter
        local project_root = find_git_root(bufname)
        local env_root = find_env_root(bufname)
        local shebang_path = get_interpreter_from_shebang(bufnr)

        local canonical_path = nil
        local root_dir = nil
        local client_name = nil
        local dynamic_settings = {}

        -- 1. Project Root: Highest priority.
        if project_root then
            root_dir = project_root
            dynamic_settings = {} -- Let pyrightconfig.json or default settings work

        -- 2. Environment Root: (venv, conda, etc.).
        elseif env_root then
            local interpreter_path = vim.fn.resolve(env_root .. '/bin/python3')

            if interpreter_path and interpreter_path ~= "" then
                canonical_path = interpreter_path
                root_dir = env_root
                dynamic_settings = { python = { pythonPath = canonical_path } }
            end

        -- 3. Shebang: (single-file script).
        elseif shebang_path then
            canonical_path = shebang_path -- Already canonical from helper
            root_dir = vim.fn.fnamemodify(bufname, ":h")
            dynamic_settings = { python = { pythonPath = canonical_path } }

        -- 4. Fallback
        else
            root_dir = vim.fn.fnamemodify(bufname, ":h")
            dynamic_settings = {}
        end

        -- Merge default and dynamic settings
        local final_lsp_settings = vim.tbl_deep_extend(
            "force",
            vim.deepcopy(default_pyright_lsp_settings),
            dynamic_settings
        )

        -- Now, check for deduplication based on the *final* interpreter path
        local final_interpreter_path = nil
        if final_lsp_settings.python and final_lsp_settings.python.pythonPath then
            final_interpreter_path = vim.fn.resolve(final_lsp_settings.python.pythonPath)
        end

        if final_interpreter_path then
            local existing_client = find_client_by_interpreter(final_interpreter_path)
            if existing_client then
                client_name = existing_client.name
                root_dir = existing_client.config.root_dir -- CRITICAL: Use existing root
            end
        end

        -- Set client_name if not already set by project or attach logic
        -- LSP deduplicates based on (client name, root dir)
        if not client_name then
            if canonical_path then
                -- New env or shebang
                client_name = "basedpyright-env-" .. vim.fn.sha256(canonical_path):sub(1, 12)
            else
                -- New global/default
                client_name = "basedpyright-global"
            end
        end

        -- Use the neovim_venv and on_attach variables
        local lsp_cmd = { neovim_venv .. '/bin/basedpyright-langserver', '--stdio' }

        -- Start the LSP client
        vim.lsp.start({
            name = client_name,
            cmd = lsp_cmd,
            root_dir = root_dir,
            settings = final_lsp_settings,
            on_attach = on_attach,
        })
    end,
})
