local M = {}

-- Allow site- or company-specific config outside public setup repo
local site_config_dir = os.getenv("HOME") .. "/etc/site"
local function get_site_config(file, default)
    local search_path = site_config_dir .. "/" .. file
    local have_config, config = pcall(dofile, search_path)
    if have_config then
        return config
    else
        return default
    end
end

-- Complicated setup for ty Python LSP server
-- The key thing we're trying to do here is automatically add import paths based on
-- shebang lines, falling back to the default interpreter, and ensure duplicate servers
-- are not started up. This is important to properly support editing of both single-file
-- scripts and modules in large project repos.
-- Below this line is mostly generated by Google Gemini


local excluded_py_paths = get_site_config("nvim-python-excludepaths.lua", {})
local default_py_exe = get_site_config("nvim-python-default-exe.lua", nil)
if not default_py_exe then
    default_py_exe = vim.fn.exepath("python3")
end

local default_pyright_lsp_settings = {
    python = {
        pythonPath = default_py_exe
    },
    ty = {
        configuration = {
            environment = {
                python = default_py_exe
            },
            src = {
                exclude = excluded_py_paths
            }
        }
    }
}


-- Helper to find a parent directory containing an item matching the provided pattern
-- (From nvim-lspconfig with modification)
local function root_pattern(return_with_suffix, ...)
    local patterns = vim.iter({ ... }):flatten():totable()

    ---@param fname string
    return function(fname)
        local path = vim.fs.normalize(fname)
        if not path then return nil end
        path = vim.fs.dirname(path)
        if not path then return nil end

        local stop = vim.fs.dirname(vim.env.HOME)
        local start_dev = vim.loop.fs_stat(path).dev
        local curr_dev = start_dev
        while path and path ~= stop and curr_dev == start_dev and path ~= '/' do
            for _, pattern in ipairs(patterns) do
                local mark = path .. '/' .. pattern
                if vim.fn.filereadable(mark) == 1 or vim.fn.isdirectory(mark) == 1 then
                    if return_with_suffix then
                        return vim.fs.normalize(mark)
                    else
                        return vim.fs.normalize(path)
                    end
                end
            end
            path = vim.fs.dirname(path)
            curr_dev = vim.loop.fs_stat(path).dev
        end
        return nil
    end
end

-- Helper to find the .git root
local find_project_root = root_pattern(false, '.git', "pyproject.toml", "ty.toml")

-- Helper to find an environment root by looking for .venv/bin/python3
local find_env_root = root_pattern(true, '.venv/bin/python3', 'venv/bin/python3', 'bin/python3')

local find_ty_toml = root_pattern(true, "ty.toml")

-- Helper to parse the shebang line and return a canonical path
local function get_interpreter_from_shebang(bufnr)
    bufnr = bufnr or 0
    local lines = vim.api.nvim_buf_get_lines(bufnr, 0, 1, false)
    if not lines or #lines == 0 then return nil end
    local line = lines[1]
    if not line:match("^#!") then return nil end

    local path
    local env_cmd = line:match("^#!%s*/usr/bin/env%s+([^%s]+)")

    if env_cmd then
        path = vim.fn.exepath(env_cmd)
    else
        path = line:match("^#!%s*([%/][^%s]+)")
    end

    if path and path ~= "" and vim.fn.executable(path) == 1 then
        return path -- Already canonical
    end
    return nil
end


local function py_exe_to_prefix(python3_exe_path)
    if not python3_exe_path then return nil end
    return string.gsub(python3_exe_path, "/bin/python[3]?$", "", 1)
end


-- Helper to find an active client by its associated Python interpreter
local function find_client_by_interpreter(interpreter_root)
    if not interpreter_root or interpreter_root == "" then return nil end

    local clients = vim.lsp.get_clients()
    for _, client in ipairs(clients) do
        if client.config and client.config.settings and client.config.settings.python then
            local client_path = client.config.settings.python.pythonPath
            if (
                client_path
                and py_exe_to_prefix(vim.fn.resolve(client_path)) == py_exe_to_prefix(resolved_path)
            ) then
                return client
            end
        end
    end
    return nil
end

-- ty custom startup logic

M.setup_ty = function(neovim_venv, lsp_on_attach_cb)
    local python_lsp_group = vim.api.nvim_create_augroup('MyPythonLspStart', { clear = true })

    vim.api.nvim_create_autocmd('FileType', {
        pattern = 'python',
        group = python_lsp_group,
        desc = "Start ty with dynamic interpreter logic",
        callback = function(args)
            local bufnr = args.buf
            local bufname = vim.api.nvim_buf_get_name(bufnr)

            -- Determine root and interpreter
            local project_root = find_project_root(bufname)
            local env_root = os.getenv("VIRTUAL_ENV") or find_env_root(bufname)
            if env_root ~= nil then
                env_root = py_exe_to_prefix(env_root)
            end
            local shebang_path = get_interpreter_from_shebang(bufnr)
            local have_ty_toml = find_ty_toml(bufname) ~= nil

            local canonical_path = nil
            local root_dir = nil
            local client_name = nil
            local dynamic_settings = {}

            local have_ty_toml = false

            -- 1. Project Root: Highest priority.
            if project_root then
                root_dir = project_root
                dynamic_settings = {} -- Let ty.toml or default settings work
            end

            -- 2. Environment Root: (venv, conda, etc.).
            if have_ty_toml then

            elseif env_root then
                local interpreter_path = vim.fn.resolve(env_root .. '/bin/python3')

                if interpreter_path and interpreter_path ~= "" then
                    canonical_path = interpreter_path
                    if root_dir == nil then
                        root_dir = env_root
                    end
                    dynamic_settings = {
                        python = { pythonPath = canonical_path },
                        ty = { configuration = { environment = {python = env_root} } }
                    }
                end

            -- 3. Shebang: (single-file script).
            elseif shebang_path then
                canonical_path = shebang_path -- Already canonical from helper
                local interpreter_root = py_exe_to_prefix(shebang_path)
                if root_dir == nil then
                    root_dir = vim.fn.fnamemodify(bufname, ":h")
                end
                dynamic_settings = {
                    python = { pythonPath = canonical_path },
                    ty = { configuration = { environment = {python = interpreter_root} } }
                }

            -- 4. Fallback
            elseif root_dir == nil then
                root_dir = vim.fn.fnamemodify(bufname, ":h")
                dynamic_settings = {}
            else
                dynamic_settings = {}
            end

            -- Merge default and dynamic settings
            local final_lsp_settings = vim.tbl_deep_extend(
                "force",
                vim.deepcopy(default_pyright_lsp_settings),
                dynamic_settings
            )

            -- Now, check for deduplication based on the *final* interpreter path
            local final_interpreter_path = nil
            if final_lsp_settings.ty.configuration.environment.python then
                final_interpreter_path = vim.fn.resolve(final_lsp_settings.ty.configuration.environment.python)
            elseif final_lsp_settings.python.pythonPath then
                final_interpreter_path = py_exe_to_prefix(vim.fn.resolve(final_lsp_settings.python.pythonPath))
            end

            if final_interpreter_path then
                local existing_client = find_client_by_interpreter(final_interpreter_path)
                if existing_client then
                    client_name = existing_client.name
                    root_dir = existing_client.config.root_dir -- CRITICAL: Use existing root
                end
            end

            -- Set client_name if not already set by project or attach logic
            -- LSP deduplicates based on (client name, root dir)
            if not client_name then
                if canonical_path then
                    -- New env or shebang
                    client_name = "ty-env-" .. vim.fn.sha256(canonical_path):sub(1, 12)
                else
                    -- New global/default
                    client_name = "ty-global"
                end
            end

            -- Define the command line for the language server
            --
            -- Prefer to invoke via 'node' exe instead of bundled node, to allow using
            -- an optimized or newer NodeJS build, if we have 'node' on the PATH
            --
            -- Note, this won't actually get invoked if a suitable instance is already
            -- running that we can attach to
            local lsp_cmd = { neovim_venv .. "/bin/ty", "server" }

            -- Start the LSP client
            vim.lsp.start({
                name = client_name,
                cmd = lsp_cmd,
                root_dir = root_dir,
                settings = final_lsp_settings,
                on_attach = on_attach,
            })
        end,
    })
end

return M
